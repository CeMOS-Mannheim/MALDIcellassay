intensities.insert(intensities.end(), currentIntensity.begin(), currentIntensity.end());
snr.insert(snr.end(), currentSnr.begin(), currentSnr.end());
} else {
nonEmpty[i] = false;
}
}
// Loop to discard close peaks
std::vector<bool> keep(mass.size(), true);
int lastSample = samples[0];
double lastMass = mass[0];
for (size_t i = 1; i < mass.size(); ++i) {
if (samples[i] == lastSample && std::abs(mass[i] - lastMass) <= tolerance) {
keep[i] = false;  // Discard subsequent peak within tolerance
} else {
lastSample = samples[i];
lastMass = mass[i];
}
}
// Filtering based on the 'keep' vector
std::vector<double> filteredMass, filteredIntensities, filteredSnr;
std::vector<int> filteredSamples;
for (size_t i = 0; i < mass.size(); ++i) {
if (keep[i]) {
filteredMass.push_back(mass[i]);
filteredIntensities.push_back(intensities[i]);
filteredSnr.push_back(snr[i]);
filteredSamples.push_back(samples[i]);
}
}
// Reconstruct the MassPeak objects with the new vectors
for (int i = 0, j = 0; i < n; ++i) {
if (nonEmpty[i]) {
S4 massPeak = l[i];
size_t len = std::count(filteredSamples.begin(), filteredSamples.end(), i + 1);
massPeak.slot("mass") = NumericVector(filteredMass.begin() + j, filteredMass.begin() + j + len);
massPeak.slot("intensity") = NumericVector(filteredIntensities.begin() + j, filteredIntensities.begin() + j + len);
massPeak.slot("snr") = NumericVector(filteredSnr.begin() + j, filteredSnr.begin() + j + len);
l[i] = massPeak;
j += len;
}
}
return l;
}
')
Rcpp::sourceCpp(code='
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]
List binPeaksRcpp(List l, String method, double tolerance) {
if (method != "strict") {
stop("Only strict method is implemented in binPeaksRcpp");
}
int n = l.size();
std::vector<bool> nonEmpty(n);
std::vector<int> samples;
std::vector<double> mass, intensities, snr;
// Populate vectors
for (int i = 0; i < n; ++i) {
S4 massPeak = l[i];
NumericVector currentMass = massPeak.slot("mass");
NumericVector currentIntensity = massPeak.slot("intensity");
NumericVector currentSnr = massPeak.slot("snr");
if (currentMass.size() > 0) {
nonEmpty[i] = true;
samples.insert(samples.end(), currentMass.size(), i + 1);  // 1-based index for R compatibility
mass.insert(mass.end(), currentMass.begin(), currentMass.end());
intensities.insert(intensities.end(), currentIntensity.begin(), currentIntensity.end());
snr.insert(snr.end(), currentSnr.begin(), currentSnr.end());
} else {
nonEmpty[i] = false;
}
}
// Loop to discard close peaks
std::vector<bool> keep(mass.size(), true);
int lastSample = samples[0];
double lastMass = mass[0];
for (size_t i = 1; i < mass.size(); ++i) {
if (samples[i] == lastSample && std::abs(mass[i] - lastMass) <= tolerance) {
keep[i] = false;  // Discard subsequent peak within tolerance
} else {
lastSample = samples[i];
lastMass = mass[i];
}
}
// Filtering based on the 'keep' vector
std::vector<double> filteredMass, filteredIntensities, filteredSnr;
std::vector<int> filteredSamples;
for (size_t i = 0; i < mass.size(); ++i) {
if (keep[i]) {
filteredMass.push_back(mass[i]);
filteredIntensities.push_back(intensities[i]);
filteredSnr.push_back(snr[i]);
filteredSamples.push_back(samples[i]);
}
}
// Reconstruct the MassPeak objects with the new vectors
for (int i = 0, j = 0; i < n; ++i) {
if (nonEmpty[i]) {
S4 massPeak = l[i];
size_t len = std::count(filteredSamples.begin(), filteredSamples.end(), i + 1);
massPeak.slot("mass") = NumericVector(filteredMass.begin() + j, filteredMass.begin() + j + len);
massPeak.slot("intensity") = NumericVector(filteredIntensities.begin() + j, filteredIntensities.begin() + j + len);
massPeak.slot("snr") = NumericVector(filteredSnr.begin() + j, filteredSnr.begin() + j + len);
l[i] = massPeak;
j += len;
}
}
return l;
}
')
Rcpp::sourceCpp(code='
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]
List binPeaksRcpp(List l, String method, double tolerance) {
if (method != "strict") {
stop("Only strict method is implemented in binPeaksRcpp");
}
int n = l.size();
std::vector<bool> nonEmpty(n);
std::vector<int> samples;
std::vector<double> mass, intensities, snr;
// Populate vectors
for (int i = 0; i < n; ++i) {
S4 massPeak = l[i];
NumericVector currentMass = massPeak.slot("mass");
NumericVector currentIntensity = massPeak.slot("intensity");
NumericVector currentSnr = massPeak.slot("snr");
if (currentMass.size() > 0) {
nonEmpty[i] = true;
samples.insert(samples.end(), currentMass.size(), i + 1);  // 1-based index for R compatibility
mass.insert(mass.end(), currentMass.begin(), currentMass.end());
intensities.insert(intensities.end(), currentIntensity.begin(), currentIntensity.end());
snr.insert(snr.end(), currentSnr.begin(), currentSnr.end());
} else {
nonEmpty[i] = false;
}
}
// Loop to discard close peaks
std::vector<bool> keep(mass.size(), true);
int lastSample = samples[0];
double lastMass = mass[0];
for (size_t i = 1; i < mass.size(); ++i) {
if (samples[i] == lastSample && std::abs(mass[i] - lastMass) <= tolerance) {
keep[i] = false;  // Discard subsequent peak within tolerance
} else {
lastSample = samples[i];
lastMass = mass[i];
}
}
// Filtering based on the keep vector
std::vector<double> filteredMass, filteredIntensities, filteredSnr;
std::vector<int> filteredSamples;
for (size_t i = 0; i < mass.size(); ++i) {
if (keep[i]) {
filteredMass.push_back(mass[i]);
filteredIntensities.push_back(intensities[i]);
filteredSnr.push_back(snr[i]);
filteredSamples.push_back(samples[i]);
}
}
// Reconstruct the MassPeak objects with the new vectors
for (int i = 0, j = 0; i < n; ++i) {
if (nonEmpty[i]) {
S4 massPeak = l[i];
size_t len = std::count(filteredSamples.begin(), filteredSamples.end(), i + 1);
massPeak.slot("mass") = NumericVector(filteredMass.begin() + j, filteredMass.begin() + j + len);
massPeak.slot("intensity") = NumericVector(filteredIntensities.begin() + j, filteredIntensities.begin() + j + len);
massPeak.slot("snr") = NumericVector(filteredSnr.begin() + j, filteredSnr.begin() + j + len);
l[i] = massPeak;
j += len;
}
}
return l;
}
')
Rcpp::sourceCpp(code='
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]
List binPeaksRcpp(List l, String method, double tolerance) {
if (method != "strict") {
stop("Only strict method is implemented in binPeaksRcpp");
}
int n = l.size();
std::vector<bool> nonEmpty(n);
std::vector<int> samples;
std::vector<double> mass, intensities, snr;
// Populate vectors
for (int i = 0; i < n; ++i) {
S4 massPeak = l[i];
NumericVector currentMass = massPeak.slot("mass");
NumericVector currentIntensity = massPeak.slot("intensity");
NumericVector currentSnr = massPeak.slot("snr");
if (currentMass.size() > 0) {
nonEmpty[i] = true;
samples.insert(samples.end(), currentMass.size(), i + 1);  // 1-based index for R compatibility
mass.insert(mass.end(), currentMass.begin(), currentMass.end());
intensities.insert(intensities.end(), currentIntensity.begin(), currentIntensity.end());
snr.insert(snr.end(), currentSnr.begin(), currentSnr.end());
} else {
nonEmpty[i] = false;
}
}
// Loop to discard close peaks
std::vector<bool> keep(mass.size(), true);
int lastSample = samples[0];
double lastMass = mass[0];
for (size_t i = 1; i < mass.size(); ++i) {
if (samples[i] == lastSample && std::abs(mass[i] - lastMass) <= tolerance) {
keep[i] = false;  // Discard subsequent peak within tolerance
} else {
lastSample = samples[i];
lastMass = mass[i];
}
}
// Filtering based on the keep vector
std::vector<double> filteredMass, filteredIntensities, filteredSnr;
std::vector<int> filteredSamples;
for (size_t i = 0; i < mass.size(); ++i) {
if (keep[i]) {
filteredMass.push_back(mass[i]);
filteredIntensities.push_back(intensities[i]);
filteredSnr.push_back(snr[i]);
filteredSamples.push_back(samples[i]);
}
}
// Reconstruct the MassPeak objects with the new vectors
for (int i = 0, j = 0; i < n; ++i) {
if (nonEmpty[i]) {
S4 massPeak = l[i];
size_t len = std::count(filteredSamples.begin(), filteredSamples.end(), i + 1);
massPeak.slot("mass") = NumericVector(filteredMass.begin() + j, filteredMass.begin() + j + len);
massPeak.slot("intensity") = NumericVector(filteredIntensities.begin() + j, filteredIntensities.begin() + j + len);
massPeak.slot("snr") = NumericVector(filteredSnr.begin() + j, filteredSnr.begin() + j + len);
l[i] = massPeak;
j += len;
}
}
return l;
}
')
benchmark <- microbenchmark::microbenchmark(
binPeaksRcpp(peaks, method = "strict", tolerance = 0.002),
binPeaksOptimizedV3(peaks, tolerance=0.002, method = "strict"),
binPeaksOptimizedV2(peaks, tolerance=0.002, method = "strict"),
binPeaksOptimized(peaks, tolerance=0.002, method = "strict"),
binPeaks(peaks, tolerance=0.002, method = "strict"),
times=25L
)
benchmark
# check if result is the same from binPeaks and binPeaksRcpp
identical(binPeaks(peaks, tolerance=0.002, method = "strict"), binPeaksRcpp(peaks, method = "strict", tolerance = 0.002))
org <-  binPeaks(peaks, tolerance=0.002, method = "strict")
rcpp <- binPeaksRcpp(peaks, method = "strict", tolerance = 0.002)
dim(intensityMatrix(org))
dim(intensityMatrix(rcpp))
dim(intensityMatrix(binPeaksOptimizedV2(peaks, tolerance=0.002, method = "strict")))
dim(intensityMatrix(binPeaksOptimized(peaks, tolerance=0.002, method = "strict")))
Rcpp::sourceCpp(code = '
#include <Rcpp.h>
using namespace Rcpp;
// Function to check if all elements are in the tolerated range
bool allInTolerance(const std::vector<double>& mass, double meanMass, double tolerance) {
return std::all_of(mass.begin(), mass.end(), [&](double m) {
return std::abs(m - meanMass) / meanMass <= tolerance;
});
}
// [[Rcpp::export]]
List binPeaksRcpp(List l, String method, double tolerance) {
// Validating method and converting to C++ types
if(method != "strict") {
throw std::range_error("Only strict method is implemented in binPeaksRcpp.");
}
int n = l.size();
std::vector<int> samples;
std::vector<double> allMass, allIntensities, allSnr;
// Store original mass sample number/ID and consolidate mass, intensities, and snr
for (int i = 0; i < n; ++i) {
S4 massPeaks = l[i];
NumericVector mass = massPeaks.slot("mass");
NumericVector intensity = massPeaks.slot("intensity");
NumericVector snr = massPeaks.slot("snr");
allMass.insert(allMass.end(), mass.begin(), mass.end());
allIntensities.insert(allIntensities.end(), intensity.begin(), intensity.end());
allSnr.insert(allSnr.end(), snr.begin(), snr.end());
samples.insert(samples.end(), mass.size(), i + 1);  // using 1-based indexing for R compatibility
}
// Sort all vectors by mass
IntegerVector order = match(allMass, sort_unique(allMass));
// Sort masses, intensities, snr, and samples based on the sorted order of mass
std::vector<double> mass = as<std::vector<double> >(allMass[order]);
std::vector<double> intensities = as<std::vector<double> >(allIntensities[order]);
std::vector<double> snr = as<std::vector<double> >(allSnr[order]);
std::vector<int> sortedSamples = as<std::vector<int> >(samples[order]);
// Vectors to track updated mass values
std::vector<double> updatedMass, updatedIntensities, updatedSnr;
std::vector<int> updatedSamples;
// Translating the binning logic (assuming .grouperStrict does similar work here)
size_t left = 0;
while (left < mass.size()) {
size_t right = left + 1;
while (right < mass.size() && mass[right] - mass[right - 1] <= tolerance) {
++right;
}
std::vector<double> currentMass(mass.begin() + left, mass.begin() + right);
double meanMass = std::accumulate(currentMass.begin(), currentMass.end(), 0.0) / currentMass.size();
if (allInTolerance(currentMass, meanMass, tolerance)) {
updatedMass.insert(updatedMass.end(), currentMass.size(), meanMass);
updatedIntensities.insert(updatedIntensities.end(), intensities.begin() + left, intensities.begin() + right);
updatedSnr.insert(updatedSnr.end(), snr.begin() + left, snr.begin() + right);
updatedSamples.insert(updatedSamples.end(), sortedSamples.begin() + left, sortedSamples.begin() + right);
}
left = right;
}
// Regroup mass, intensities, snr, and samples by sample ID and return a list of adjusted MassPeaks objects
List adjustedPeaks(n);
for (int i = 0; i < n; ++i) {
// Find indices corresponding to the current sample and create a subvector for mass, intensity, and snr
std::vector<int>::iterator sIt, eIt;
sIt = std::lower_bound(updatedSamples.begin(), updatedSamples.end(), i + 1);
eIt = std::upper_bound(updatedSamples.begin(), updatedSamples.end(), i + 1);
NumericVector sampleMass(sIt - updatedSamples.begin(), eIt - updatedSamples.begin());
NumericVector sampleIntensity(sIt - updatedSamples.begin(), eIt - updatedSamples.begin());
NumericVector sampleSnr(sIt - updatedSamples.begin(), eIt - updatedSamples.begin());
S4 thisPeak(l[i]);  // Original S4 object
thisPeak.slot("mass") = sampleMass;
thisPeak.slot("intensity") = sampleIntensity;
thisPeak.slot("snr") = sampleSnr;
adjustedPeaks[i] = thisPeak;
}
return adjustedPeaks;
}
')
library(MALDIcellassay)
pak::pkg_install("CeMOS-Mannheim/MALDIcellassay")
devtools::document()
a <- tibble(x = 1:3, y = LETTERS[1:3])
library(tidyverse)
a <- tibble(x = 1:3, y = LETTERS[1:3])
b <- tibble(x = 1:3, y = LETTERS[4:6])
left_join(a, b, by = join_by("x"))
b <- tibble(x = 1:3, z = LETTERS[4:6])
left_join(a, b, by = join_by("x"))
MALDIcellassay:::.calculateZPrime(rnorm(8, 0.001, sd = 0.05),rnorm(8, 0.002, sd = 0.1))
library(MALDIcellassay)
spec <- loadSpectraMzML("C:/Data/m2ara_figshare/mzML/")
devtools::load_all()
spec <- loadSpectraMzML("C:/Data/m2ara_figshare/mzML/")
res <- fitCurve(spec = spec,
unit = "nM",
varFilterMethod = "none",
normMz = 354.1,
alignTol = 0,
halfWindowSize = 20)
plotCurves(res, 1)
devtools::document()
res <- fitCurve(spec = spec,
unit = "nM",
varFilterMethod = "none",
normMz = 354.1,
alignTol = 0,
halfWindowSize = 20)
MALDIcellassay::getFittingParameters(res)
calculatePeakStatistics(res@fits, res@singlePeaks)
calculatePeakStatistics(res@fits, res@singlePeaks, spec = res@avgSpectra)
calculatePeakStatistics(res@fits, res@avgPeaks, spec = res@avgSpectra)
100*1e-6
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
library(MALDIquant)
spec <- suppressWarnings(
smoothIntensity(spec,
method = "SawitzkyGolay",
halfWindowSize = 10)
)
spec <- suppressWarnings(
smoothIntensity(spec,
method = "SavitzkyGolay",
halfWindowSize = 10)
)
spec <- suppressWarnings(
removeBaseline(spec,
method = "TopHat")
)
res <- fitCurve(spec = spec,
unit = "nM",
varFilterMethod = "none",
normMz = 857.133,
binTol = 100*1e-6,
SinglePointRecal = TRUE,
alignTol = 0,
halfWindowSize = 20)
source("~/.active-rstudio-document", echo=TRUE)
getPeakStatistics(res)
getPeakStatistics(res) %>%
mutate(z = calculateZPrime(res))
getPeakStatistics(res, TRUE) %>%
mutate(z = calculateZPrime(res))
stats <- getPeakStatistics(res, TRUE) %>%
mutate(z = calculateZPrime(res),
v = calculateVPrime(res))
View(stats)
res <- fitCurve(spec = spec,
unit = "nM",
varFilterMethod = "none",
normMz = 857.133,
binTol = 100*1e-6,
SinglePointRecal = TRUE,
alignTol = 0,
halfWindowSize = 3)
stats <- getPeakStatistics(res, TRUE) %>%
mutate(z = calculateZPrime(res),
v = calculateVPrime(res))
View(stats)
plotCurves(res, 87, errorbars = "sd")
stats <- getPeakStatistics(res, TRUE) %>%
mutate(z = round(calculateZPrime(res),2),
v = round(calculateVPrime(res),2))
View(stats)
plotCurves(res, 297, errorbars = "sd")
plotCurves(res, 298, errorbars = "sd")
plotCurves(res, 12, errorbars = "sd")
plotCurves(res, 309, errorbars = "sd")
plotCurves(res, 207, errorbars = "sd")
intmat <- getIntensityMatrix(res,
avg = FALSE,
excludeNormMz = FALSE)
View(intmat)
plotCurves(res, 207, errorbars = "sd")
plotCurves(res, 307, errorbars = "sd")
plotCurves(res, 299, errorbars = "sd")
plotCurves(res, 34, errorbars = "sd")
plotCurves(res, 27, errorbars = "sd")
plotCurves(res, 324, errorbars = "sd")
plotCurves(res, 125, errorbars = "sd")
spec <- loadSpectra("c:/Data/m2ara_figshare/Curve/")
source("~/.active-rstudio-document", echo=TRUE)
View(stats)
View(stats %>% arrange(z))
View(stats %>% arrange(desc(z))) %>% filter(v<0.1)
library(tidyverse)
View(stats %>% arrange(desc(z))) %>% filter(v<0.1)
View(stats %>% arrange(desc(z)) %>% filter(v<0.1))
View(stats %>% arrange(desc(v)) %>% filter(z>0))
plotCurves(res, 3, errorbars = "sd")
intmat <-  getIntensityMatrix(res)
intmat[,3]
top <- intmat[81:88,3]
bot <- intmat[1:8,3]
MALDIcellassay:::.calculateZPrime(top, bot)
MALDIcellassay:::.getTopAndBottomIntensityMatrix(res)
MALDIcellassay:::.getTopAndBottomIntensityMatrix(res, 2)
a <- MALDIcellassay:::.getTopAndBottomIntensityMatrix(res, 2)
View(a)
a$pos
debugonce(MALDIcellassay:::.getTopAndBottomIntensityMatrix)
a <- MALDIcellassay:::.getTopAndBottomIntensityMatrix(res, 2)
concs[1:nConc]
length(concs)
nConc+1
(length(concs)-nConc+1)
concs[(length(concs)-nConc+1):length(concs)])
concs[(length(concs)-nConc+1):length(concs)]
range(concs)
concs[1:nConc])
concs[1:nConc]
concs[(length(concs)-nConc+1):length(concs)]
range(concs)
getIntensityMatrix(res,
avg = FALSE,
excludeNormMz = FALSE)
stats %>% arrange(desc(v))) %>% filter(z>0)
stats %>% arrange(desc(v)) %>% filter(z>0)
stats %>% arrange(desc(v)) %>% filter(z>0) %>% View()
topBot < MALDIcellassay:::.getTopAndBottomIntensityMatrix(res, nConc = 2)
topBot <- MALDIcellassay:::.getTopAndBottomIntensityMatrix(res, nConc = 2)
MALDIcellassay:::.calculateZPrime(topBot$pos[,3], topBot$neg[,3])
View(spec)
bot <- intmat[1:18,3]
top <- intmat[72:88,3]
MALDIcellassay:::.calculateZPrime(top, bot)
stats %>% arrange(desc(v)) %>% filter(z>0) %>% View()
plotCurves(res, 3, errorbars = "sd")
intmat <-  getIntensityMatrix(res)
View(intmat)
MALDIcellassay:::.calculateZPrime(top, bot)
mean(bot)
mean(top)
sd(bot)
sd(top)
sd(top)+sd(bot)
(sd(top)+sd(bot))(abs(mean(bot)-mean(top)))
(sd(top)+sd(bot))/(abs(mean(bot)-mean(top)))
rownames(intmat) <- getConc(res)
bot <- intmat[1:18,3]
bot1 <- intmat[1:9,3]
bot2 <- intmat[10:18,3]
top <- intmat[72:88,3]
top1 <- intmat[72:81,3]
top2 <- intmat[82:88,3]
sd(bot)
mean(c(sd(bot1), sd(bot2)))
sd(top)
mean(c(sd(top1), sd(top2)))
MALDIcellassay:::.calculateZPrime(top, bot)
1 - (3 * (mean(c(sd(top1), sd(top2))) + mean(c(sd(bot1), sd(bot2)))) / (abs(mean(top) - mean(bot))))
View(stats)
stats %>% arrange(desc(v)) %>% filter(z>0) %>% View()
plotCurves(res, 92, "sd")
plotCurves(res, 103, "sd")
View(stats)
